<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>

<input id="file" type="file">

<script>

    const DefaultChunkSize = 1024 * 1024 * 2;

    const file_element = document.getElementById("file");
    file_element.onchange = async () => {

        const file = file_element.files.item(0);
        file_element.value = null;

        // const chunkList = sliceFile(file);
        // for (let i = 0; i < chunkList.length; i++) {
        //     await upload(chunkList[i], i);
        // }
        //

        const chunkFile = new ChunkFile(file, DefaultChunkSize);
        chunkFile.process();
        chunkFile.iter((chunk, index) => {
            upload(chunk, index);
        });
        await mergeChunkFile('123', 'beau.png', DefaultChunkSize);

    }

    /**
     * Cut a file into a set of block of specified size.
     * @param {File} file
     * @param {Number} chunkSize - Bytes unit
     * @returns {Array<Blob>}
     */
    function sliceFile(file, chunkSize = DefaultChunkSize) {

        const chunkList = [];
        let current = 0;

        while (current < file.size) {
            const chunk = file.slice(current, current + chunkSize, file.type);
            chunkList.push(chunk);
            current += chunkSize;
        }

        return chunkList;
    }

    function upload(file, index) {
        const formData = new FormData();
        formData.append('chunk', file);
        formData.append('fileHash', '123');
        formData.append('chunkHash', index);
        formData.append('index', index);
        return axios({
            method: 'POST',
            url: 'http://localhost:3000/chunk-upload',
            headers: {
                "Content-Type": "multipart/form-data"
            },
            data: formData
        });
    }

    function mergeChunkFile(hash, fileName, chunkSize) {
        const formData = new FormData();
        formData.append('hash', hash);
        formData.append('fileName', fileName);
        formData.append('chunkSize', chunkSize);
        return axios({
            method: 'POST',
            url: 'http://localhost:3000/chunk-merge',
            data: formData
        });
    }

</script>

<script>

    /**
     * 一个管理切片的文件对象
     */
    class ChunkFile {

        /** @type {Array<Blob>} */
        _buffer = [];

        /** @type {Number} */
        _iterIndex = 0;

        /** @type {File} */
        _file = null;

        /** @type {Number} */
        _chunkSize;

        /**
         * @param {File} file
         * @param {Number} chunkSize
         */
        constructor(file, chunkSize) {
            this._file = file;
            this._chunkSize = chunkSize;
        }

        process() {
            let current = 0;
            const { type, size } = this._file;
            while (current < size) {
                const chunk = this._file.slice(current, current + this._chunkSize, type);
                this._buffer.push(chunk);
                current += this._chunkSize;
            }
        }

        getNext() {
            if (this._iterIndex < this._buffer.length) {
                return this._buffer[this._iterIndex++];
            } else {
                return null;
            }
        }

        /**
         * @param { (chunk: Blob, index: Number) => void } fn
         */
        iter(fn) {
            this._buffer.forEach(fn);
        }

        /**
         * 设置内部迭代指针的位置，使其指向特定的切片位置
         * @param index
         */
        setOffset(index) {

            if (index >= this._buffer.length || index < 0) {
                throw new Error("Point to an empty index.");
            }

            this._iterIndex = index;
        }

        [Symbol.iterator]() {
            let index = 0;
            return {
                next: () => {
                    return (
                        index < this._buffer.length
                            ? { value: this._buffer[index++], done: false }
                            : { done: true }
                    )
                }
            }
        }
    }

    class ChunkManager {

        _files = [];
        _chunkSize = 0;

        constructor(chunkSize) {
            this._chunkSize = chunkSize;
        }

        /**
         * @param { ChunkFile | File } file
         */
        append(file) {
            if (file instanceof ChunkFile) {
                this._files.push(file);
            } else if (file instanceof File) {
                this._files.push(new ChunkFile(file, this._chunkSize));
            }
        }

    }

</script>

</body>
</html>